//////////////////////////////////////////////
//
//		   City Transport Tycoon
//	   Copyright (C) Black Ice Mountains
//		 	All rights reserved
//
// File		: io/Config.cpp
// Author	: Eryk Dwornicki
//
//////////////////////////////////////////////

#include "Config.h"

#include <json/json.h>

#include <io/fs/FileSystem.h>

#include <time.h>

#include <core/StringUtilities.h>

#include <Debugging.h>

Config * Config::s_singleton = 0;

Config::Config()
{
	s_singleton = this;
}

Config::~Config()
{
	s_singleton = 0;

	for (Config::Entry *entry : m_entries)
		delete entry;

	m_entries.clear();
}

void Config::serialize(File *file)
{
	Json::StyledWriter writer;
	Json::Value root;
	for (Config::Entry *entry : m_entries)	
		entry->serialize(file, root);	

	std::string data = writer.write(root);

	time_t timeraw = time(NULL);
	struct tm * timeInfo = localtime(&timeraw);

	char time[64] = { 0 };
	sprintf(time, "%02d.%02d.%04d %02d:%02d:%02d", timeInfo->tm_mday, timeInfo->tm_mon + 1, timeInfo->tm_year + 1900, timeInfo->tm_hour, timeInfo->tm_min, timeInfo->tm_sec);
	String<512> comment("// This file has been generated by City Transport Tycoon game.\n// Do not edit it if you are not sure about that what you are doing.\n// Generate time: %s\n", time);
	file->write(comment.get(), comment.getLength(), sizeof(uint8));
	file->write(data.c_str(), data.length(), sizeof(uint8));
	file->flush();
}

void Config::deserialize(File* file)
{
	BIM_ASSERT(file, "Null file pointer.");

	if (file->isLoaded())
	{
		DynString data = file->getContent();
		if (data.getLength() > 0)
		{
			Json::Reader reader;
			Json::Value root;
			if (reader.parse(data.get(), root))
			{
				for (std::string names : root.getMemberNames())
				{
					Config::Entry *newEntry = new Config::Entry (names.c_str());					
					newEntry->deserialize(file, root);
					m_entries.pushBack(newEntry);
				}
			}
			else
			{
				Error("config", "Cannot deserialize configuration file. %s", reader.getFormatedErrorMessages().c_str());
			}
		}
	}
}

Config& Config::get()
{
	return *s_singleton;
}

Config::Entry& Config::find(const DynString& name)
{
	for (Config::Entry* entry : m_entries)
	{
		if (entry->m_name == name)
		{
			return *entry;
		}
	}

	Config::Entry *entry = new Config::Entry(name);
	m_entries.pushBack(entry);
	return *entry;
}

Config::Entry& Config::operator[](const DynString& name)
{
	return find(name);
}

Config::Entry::Entry(const DynString& name)
	: m_name(name), m_type(Config::Entry::ValueType::Empty)
{
}

Config::Entry::Entry()
	: m_type(Config::Entry::ValueType::Empty)
{
}

Config::Entry::~Entry()
{
	for (Config::Entry * entry : m_data.arrayData)
		delete entry;

	m_data.arrayData.clear();
}

uint32 Config::Entry::getInteger(uint32 def)
{
	if (m_type == Config::Entry::ValueType::Integer)
		return m_data.integerValue;
	
	m_type = Config::Entry::ValueType::Integer;
	m_data.integerValue = def;
	return def;
}

float Config::Entry::getFloat(float def)
{
	if (m_type == Config::Entry::ValueType::Float)
		return m_data.floatValue;
	else if (m_type == Config::Entry::ValueType::Integer)
		return (float)m_data.integerValue;

	m_type = Config::Entry::ValueType::Float;
	m_data.floatValue = def;
	return def;
}

List<Config::Entry *> Config::Entry::getArrayData()
{
	return m_data.arrayData;
}

DynString Config::Entry::getString(const DynString& def)
{
	if (m_type == Config::Entry::ValueType::String) 
		return m_data.stringData;
	
	m_type = Config::Entry::ValueType::String;
	m_data.stringData = def;
	return def;
}

bool Config::Entry::getBool(bool def)
{
	if (m_type == Config::Entry::ValueType::Boolean)
		return m_data.booleanData;

	m_type = Config::Entry::ValueType::Boolean;
	m_data.booleanData = def;
	return def;
}

Config::Entry::ValueType::Type Config::Entry::type()
{
	return m_type;
}

Config::Entry& Config::Entry::operator=(uint32 v)
{
	m_type = Config::Entry::ValueType::Integer;
	m_data.integerValue = v;
	return *this;
}

Config::Entry& Config::Entry::operator=(float v)
{
	m_type = Config::Entry::ValueType::Float;
	m_data.floatValue = v;
	return *this;
}

Config::Entry& Config::Entry::operator=(const DynString& v)
{
	if (StringUtilities::isBoolean(v))
	{
		m_type = Config::Entry::ValueType::Boolean;
		m_data.booleanData = StringUtilities::toBoolean(v);
	}
	else if (StringUtilities::isInteger(v))
	{
		m_type = Config::Entry::ValueType::Integer;
		m_data.integerValue = StringUtilities::toUInt32(v);
	}
	else if (StringUtilities::isFloat(v))
	{
		m_type = Config::Entry::ValueType::Float;
		m_data.floatValue = StringUtilities::toFloat(v);
	} 
	else
	{
		m_type = Config::Entry::ValueType::String;
		m_data.stringData = v;
	}
	return *this;
}

Config::Entry& Config::Entry::operator=(bool v)
{
	m_type = Config::Entry::ValueType::Boolean;
	m_data.booleanData = v;
	return *this;
}

Config::Entry& Config::Entry::find(const DynString& name)
{
	for (Config::Entry* entry : m_data.arrayData)
	{
		if (entry->m_name == name)
		{
			return *entry;
		}
	}
	m_type = Config::Entry::ValueType::Array;
	Config::Entry *entry = new Config::Entry(name);
	m_data.arrayData.pushBack(entry);
	return *entry;
}

Config::Entry& Config::Entry::operator[](const DynString& name)
{
	return find(name);
}

void Config::Entry::serialize(File *file, Json::Value& parent)
{
	switch (m_type)
	{
	case Config::Entry::ValueType::Array:
		{
			for (Config::Entry *entry : m_data.arrayData)
				entry->serialize(file, parent[m_name.get()]);
		} break;
	case Config::Entry::ValueType::Boolean:
		{					
			parent[m_name.get()] = m_data.booleanData;
		} break;
	case Config::Entry::ValueType::Integer:
		{
			parent[m_name.get()] = m_data.integerValue;
		} break;
	case Config::Entry::ValueType::Float:
		{
			parent[m_name.get()] = m_data.floatValue;
		} break;
	case Config::Entry::ValueType::Empty:
		{
			parent[m_name.get()] = Json::nullValue;
		} break;
	case Config::Entry::ValueType::String:
		{
			parent[m_name.get()] = m_data.stringData.get();
		} break;
	}
}

void Config::Entry::deserialize(File* file, Json::Value& parent)
{
	Json::Value &value = parent[m_name.get()];
	switch(value.type())
	{
	case Json::ValueType::objectValue:
		{
			m_type = Config::Entry::ValueType::Array;
			for (std::string names : value.getMemberNames())
			{
				Config::Entry *newEntry = new Config::Entry (names.c_str());
				newEntry->deserialize(file, value);
				m_data.arrayData.pushBack(newEntry);
			}
		} break;
	case Json::ValueType::intValue:
		{ 
			m_type = Config::Entry::ValueType::Integer;
			m_data.integerValue = value.asInt();
		} break;
	case Json::ValueType::realValue:
		{
			m_type = Config::Entry::ValueType::Float;
			m_data.floatValue = value.asFloat();
		} break;
	case Json::ValueType::booleanValue:
		{
			m_type = Config::Entry::ValueType::Boolean;
			m_data.booleanData = value.asBool();
		} break;
	case Json::ValueType::nullValue:
		{
			m_type = Config::Entry::ValueType::Empty;
		} break;
	case Json::ValueType::stringValue:
		{
			m_type = Config::Entry::ValueType::String;
			m_data.stringData = value.asCString();
		} break;
	default:
		{
			Error("config", "Cannot deserialize config element '%s'. JSON type: %d", m_name.get(), value.type());
		} break;
	}
}