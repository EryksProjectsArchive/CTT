//////////////////////////////////////////////
//
//		   City Transport Tycoon
//	   Copyright (C) Black Ice Mountains
//		 	All rights reserved
//
// File		: io/Config.cpp
// Author	: Eryk Dwornicki
//
//////////////////////////////////////////////

#include "Config.h"

#include <json/json.h>

#include <io/fs/FileSystem.h>

Config::Config()
{
}

Config::~Config()
{

}

void Config::serialize(File *file)
{
	Json::StyledWriter writer;
	Json::Value root;
	root.setComment("This file has been generated by City Transport Tycoon game. Do not edit if if you are not sure about that what are you doing.", Json::CommentPlacement::commentBefore);
	for (Config::Entry entry : m_entries)
	{
		entry.serialize(file, root);
	}

	std::string data = writer.write(root);
	file->write(data.c_str(), data.length(), sizeof(uint8));
	file->flush();
}

void Config::deserialize(File* file)
{
	DynString data = file->getContent();
	Json::Reader reader;
	Json::Value root;
	if (data.getLength() > 0)
	{
		if (reader.parse(data.get(), root))
		{
			for (std::string names : root.getMemberNames())
			{
				Config::Entry newEntry(names.c_str());
				newEntry.deserialize(file, root);
				m_entries.pushBack(newEntry);
			}
		}
	}
}

Config::Entry Config::find(DynString name)
{
	for (Config::Entry entry : m_entries)
	{
		if (entry.m_name == name)
		{
			return entry;
		}
	}
	Config::Entry newEntry(name);
	m_entries.pushBack(newEntry);
	return newEntry;
}

Config::Entry Config::operator[](DynString name)
{
	return find(name);
}

Config::Entry::Entry(const DynString name)
	: m_name(name), m_type(Config::Entry::ValueType::Empty)
{
	Info("x", "%p", this);
}

Config::Entry::Entry()
	: m_name(String<64>("entry:%p", this)), m_type(Config::Entry::ValueType::Empty)
{

}

Config::Entry::~Entry()
{

}

uint32 Config::Entry::getInteger(uint32 default)
{
	if (m_type == Config::Entry::ValueType::Integer)
		return m_data.integerValue;
	
	m_type = Config::Entry::ValueType::Integer;
	m_data.integerValue = default;
	return default;
}
float Config::Entry::getFloat(float default)
{
	if (m_type == Config::Entry::ValueType::Float)
		return m_data.floatValue;
	
	m_type = Config::Entry::ValueType::Float;
	m_data.floatValue = default;
	return default;
}

List<Config::Entry>& Config::Entry::getArrayData()
{
	return m_data.arrayData;
}

DynString Config::Entry::getString(DynString default)
{
	if (m_type == Config::Entry::ValueType::String) 
		return m_data.stringData;
	
	m_type = Config::Entry::ValueType::String;
	m_data.stringData = default;
	return default;
}

bool Config::Entry::getBool(bool default)
{
	if (m_type == Config::Entry::ValueType::Boolean)
		return m_data.booleanData;

	m_type = Config::Entry::ValueType::Boolean;
	m_data.booleanData = default;
	return default;
}

Config::Entry Config::Entry::operator[](DynString name)
{
	for (Config::Entry entry : m_data.arrayData)
	{
		if (entry.m_name == name)
		{
			return entry;
		}
	}
	Config::Entry newEntry = Config::Entry(name);
	m_data.arrayData.pushBack(newEntry);
	m_type = Config::Entry::ValueType::Array;
	return newEntry;
}

void Config::Entry::serialize(File *file, Json::Value parent)
{
	switch (m_type)
	{
	case Config::Entry::ValueType::Array:
		{
			parent = parent[m_name];
			for (Config::Entry entry : m_data.arrayData)
				entry.serialize(file, parent);
		} break;
	case Config::Entry::ValueType::Boolean:
		{					
			parent[m_name] = m_data.booleanData;
		} break;
	case Config::Entry::ValueType::Integer:
		{
			parent[m_name] = m_data.integerValue;
		} break;
	case Config::Entry::ValueType::Float:
		{
			parent[m_name] = m_data.floatValue;
		} break;
	case Config::Entry::ValueType::Empty:
		{
			parent[m_name] = Json::nullValue;
		} break;
	}
}

void Config::Entry::deserialize(File* file, Json::Value parent)
{
	switch(parent[m_name].type())
	{
	case Json::ValueType::arrayValue:
		{
			m_type = Config::Entry::ValueType::Array;
			for (std::string names : parent[m_name].getMemberNames())
			{
				Config::Entry newEntry(names.c_str());
				newEntry.deserialize(file, parent[m_name]);
				m_data.arrayData.pushBack(newEntry);
			}
		} break;
	case Json::ValueType::intValue:
		{ 
			m_type = Config::Entry::ValueType::Integer;
			m_data.integerValue = parent[m_name].asInt();
		} break;
	case Json::ValueType::realValue:
		{
			m_type = Config::Entry::ValueType::Float;
			m_data.floatValue = parent[m_name].asFloat();
		} break;
	case Json::ValueType::booleanValue:
		{
			m_type = Config::Entry::ValueType::Boolean;
			m_data.booleanData = parent[m_name].asBool();
		} break;
	case Json::ValueType::nullValue:
		{
			m_type = Config::Entry::ValueType::Empty;
		} break;
	}
}